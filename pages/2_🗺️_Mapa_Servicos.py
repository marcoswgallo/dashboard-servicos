import streamlit as st
import plotly.express as px
import pandas as pd
from DB import DatabaseConnection

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Mapa de Servi√ßos",
    page_icon="üó∫Ô∏è",
    layout="wide"
)

# Estilo CSS personalizado
st.markdown("""
    <style>
    .stSlider > div > div > div {
        background-color: #ff4b4b;
    }
    .stSelectbox > div > div {
        background-color: #f0f2f6;
    }
    .metric-card {
        background-color: #ffffff;
        border-radius: 10px;
        padding: 15px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    </style>
""", unsafe_allow_html=True)

# T√≠tulo principal
st.title("üó∫Ô∏è Mapa de Servi√ßos")

# Mapeamento de bases para tipos
base_tipos = {
    'Instala√ß√£o': [
        'BASE BAURU', 'BASE BOTUCATU', 'BASE CAMPINAS', 'BASE LIMEIRA',
        'BASE PAULINIA', 'BASE PIRACICABA', 'BASE RIBEIRAO PRETO',
        'BASE SAO JOSE DO RIO PRETO', 'BASE SOROCABA', 'BASE SUMARE',
        'GPON BAURU', 'GPON RIBEIRAO PRETO'
    ],
    'Manuten√ß√£o': [
        'BASE ARARAS VT', 'BASE BOTUCATU VT', 'BASE MDU ARARAS',
        'BASE MDU BAURU', 'BASE MDU MOGI', 'BASE MDU PIRACICABA',
        'BASE MDU SJRP', 'BASE PIRACICABA VT', 'BASE RIBEIR√ÉO VT',
        'BASE SERTAOZINHO VT', 'BASE SUMARE VT', 'BASE VAR BAURU',
        'BASE VAR PIRACICABA', 'BASE VAR SUMARE'
    ],
    'Desconex√£o': [
        'DESCONEXAO', 'DESCONEX√ÉO BOTUCATU', 'DESCONEX√ÉO CAMPINAS',
        'DESCONEXAO RIBEIRAO PRETO'
    ]
}

# Fun√ß√£o para carregar dados
@st.cache_data
def load_data():
    try:
        db = DatabaseConnection()
        
        # Verificar se a tabela existe
        check_query = """
        SELECT EXISTS (
            SELECT FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'Basic'
        );
        """
        result = db.execute_query(check_query)
        if result is None or not result.iloc[0, 0]:
            st.error("‚ùå A tabela 'Basic' n√£o existe no banco de dados")
            return None
            
        # Se a tabela existe, contar registros
        count_query = "SELECT COUNT(*) FROM \"Basic\";"
        count_result = db.execute_query(count_query)
        if count_result is not None:
            total_records = count_result.iloc[0, 0]
            st.write(f"Total de registros na tabela: {total_records}")
        
        # Buscar os dados
        query = """
        SELECT *
        FROM "Basic"
        ORDER BY TO_DATE("DATA", 'DD/MM/YYYY') DESC
        LIMIT 1000;
        """
        
        df = db.execute_query(query)
        if df is not None and not df.empty:
            # Mostrar informa√ß√µes do DataFrame
            st.write(f"Colunas dispon√≠veis: {', '.join(df.columns)}")
            st.write(f"Registros carregados: {len(df)}")
            
            # Converter coluna de data para datetime usando o formato correto
            df['DATA'] = pd.to_datetime(df['DATA'], dayfirst=True)
            
            # Converter valores para num√©rico
            df['VALOR T√âCNICO'] = pd.to_numeric(df['VALOR T√âCNICO'].str.replace(',', '.'), errors='coerce')
            df['VALOR EMPRESA'] = pd.to_numeric(df['VALOR EMPRESA'].str.replace(',', '.'), errors='coerce')
            
            # Converter coordenadas para num√©rico
            df['LATIDUDE'] = pd.to_numeric(df['LATIDUDE'], errors='coerce')
            df['LONGITUDE'] = pd.to_numeric(df['LONGITUDE'], errors='coerce')
            
            # Preencher valores nulos
            df['SERVI√áO'] = df['SERVI√áO'].fillna('')
            df['CIDADES'] = df['CIDADES'].fillna('')
            df['TECNICO'] = df['TECNICO'].fillna('')
            df['BASE'] = df['BASE'].fillna('')
            
            # Criar coluna de tipo de base
            df['TIPO_BASE'] = 'Outros'
            for tipo, bases in base_tipos.items():
                df.loc[df['BASE'].isin(bases), 'TIPO_BASE'] = tipo
            
            return df
        else:
            st.error("DataFrame vazio retornado pela consulta")
            return None
    except Exception as e:
        st.error(f"Erro ao carregar dados: {str(e)}")
        return None

# Carregar dados iniciais
df = load_data()

# Container para filtros
with st.container():
    st.markdown("### üéØ Filtros")
    
    col1, col2, col3 = st.columns([2,2,1])
    
    with col1:
        dias = st.slider(
            "üìÖ Per√≠odo de an√°lise (dias):",
            min_value=1,
            max_value=90,
            value=30,
            help="Filtrar dados dos √∫ltimos X dias"
        )
        
    with col2:
        status_options = sorted(df['STATUS'].unique()) if df is not None and not df.empty else []
        status = st.multiselect(
            "üîÑ Status:",
            options=status_options,
            default=[],
            help="Filtrar por status do servi√ßo"
        )
    
    with col3:
        tipo_vis = st.selectbox(
            "üìä Visualiza√ß√£o",
            ["Pontos", "Calor"],
            help="Escolha como os dados ser√£o mostrados no mapa"
        )

    # Linha divis√≥ria sutil
    st.markdown("---")

# Query atualizada
query = f"""
SELECT *
FROM "Basic"
WHERE TO_DATE("DATA", 'DD/MM/YYYY') >= CURRENT_DATE - INTERVAL '{dias} days'
ORDER BY TO_DATE("DATA", 'DD/MM/YYYY') DESC
LIMIT 1000;
"""

# Recarregar dados com a nova query
df = load_data()

if df is not None:
    # Processamento dos dados
    df_filtered = df.copy()
    
    if status:
        df_filtered = df_filtered[df_filtered['STATUS'].isin(status)]
    
    df_map = df_filtered[df_filtered['LATIDUDE'].notna() & df_filtered['LONGITUDE'].notna()]
    
    # M√©tricas principais em cards
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.markdown("""
            <div class="metric-card">
                <h3 style="margin:0">üìä Total de Servi√ßos</h3>
                <h2 style="margin:0;color:#ff4b4b">{}</h2>
            </div>
        """.format(len(df_map)), unsafe_allow_html=True)
    
    with col2:
        st.markdown("""
            <div class="metric-card">
                <h3 style="margin:0">üèôÔ∏è Cidades Atendidas</h3>
                <h2 style="margin:0;color:#ff4b4b">{}</h2>
            </div>
        """.format(df_map['CIDADES'].nunique()), unsafe_allow_html=True)
    
    with col3:
        st.markdown("""
            <div class="metric-card">
                <h3 style="margin:0">üë®‚Äçüîß T√©cnicos Ativos</h3>
                <h2 style="margin:0;color:#ff4b4b">{}</h2>
            </div>
        """.format(df_map['TECNICO'].nunique()), unsafe_allow_html=True)
    
    with col4:
        executados = len(df_map[df_map['STATUS'] == 'EXECUTADO'])
        total = len(df_map)
        taxa_execucao = (executados/total*100) if total > 0 else 0
        st.markdown("""
            <div class="metric-card">
                <h3 style="margin:0">‚úÖ Taxa de Execu√ß√£o</h3>
                <h2 style="margin:0;color:#ff4b4b">{:.1f}%</h2>
            </div>
        """.format(taxa_execucao), unsafe_allow_html=True)

    # Formatar dados para hover
    df_map['DATA'] = pd.to_datetime(df_map['DATA'], format='%d/%m/%Y').dt.strftime('%d/%m/%Y')
    df_map['Detalhes'] = df_map.apply(
        lambda x: f"""
        üóìÔ∏è {x['DATA']}
        üë§ {x['CLIENTE']}
        üîß {x['SERVI√áO']}
        üë®‚Äçüîß {x['TECNICO']}
        üìç {x['BAIRRO']}, {x['CIDADES']}
        üè¢ Base: {x['BASE']}
        ‚ÑπÔ∏è {x['TIPO DE SERVI√áO']}
        """, 
        axis=1
    )
    
    # Criar mapa de pontos
    fig = px.scatter_mapbox(
        df_map,
        lat='LATIDUDE',
        lon='LONGITUDE',
        color='STATUS',
        color_discrete_sequence=px.colors.qualitative.Set1,
        title=f'Localiza√ß√£o dos Servi√ßos - √öltimos {dias} dias',
        hover_data={
            'LATIDUDE': False,
            'LONGITUDE': False,
            'Detalhes': True,
            'STATUS': True
        },
        hover_name='CLIENTE'
    )
    
    # Ajustar layout
    fig.update_layout(
        mapbox=dict(
            style='carto-positron',  # Estilo claro do mapa
            center=dict(
                lat=-22.01,  # Regi√£o de Campinas
                lon=-47.86
            ),
            zoom=8  # Zoom mais aberto
        ),
        showlegend=True,
        legend=dict(
            title='STATUS',
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01,
            bgcolor='rgba(255,255,255,0.8)'  # Fundo semi-transparente
        ),
        margin={"r":0,"t":30,"l":0,"b":0},
        height=600
    )
    
    # Mostrar o mapa
    st.plotly_chart(fig, use_container_width=True)

    # Se√ß√£o de Insights Inteligentes
    st.markdown("---")
    st.header("üìä Insights Operacionais")

    # An√°lise temporal dos servi√ßos
    st.subheader("üìÖ An√°lise Temporal")
    
    # Mapeamento de dias em ingl√™s para portugu√™s
    dias_semana = {
        'Monday': 'Segunda-feira',
        'Tuesday': 'Ter√ßa-feira',
        'Wednesday': 'Quarta-feira',
        'Thursday': 'Quinta-feira',
        'Friday': 'Sexta-feira',
        'Saturday': 'S√°bado',
        'Sunday': 'Domingo'
    }
    
    df_map['DIA_SEMANA'] = pd.to_datetime(df_map['DATA']).dt.day_name()
    df_map['DIA_SEMANA'] = df_map['DIA_SEMANA'].map(dias_semana)

    # Identificar picos de demanda por dia da semana
    demanda_dia = df_map.groupby('DIA_SEMANA').size()
    dias_pico = demanda_dia.nlargest(3)

    # Identificar per√≠odos com maior demanda
    demanda_periodo = df_map.groupby('PERIODO').size()
    periodos_pico = demanda_periodo.nlargest(3)

    # Mostrar an√°lise temporal em colunas
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("**Per√≠odos com Maior Demanda:**")
        for periodo, total in periodos_pico.items():
            st.write(f"- {periodo}: {total} servi√ßos")
    
    with col2:
        st.markdown("**Dias mais Movimentados:**")
        for dia, total in dias_pico.items():
            st.write(f"- {dia}: {total} servi√ßos")

    # An√°lise geogr√°fica
    st.subheader("üìç An√°lise Geogr√°fica")
    
    # Identificar clusters de demanda
    bairros_demanda = df_map.groupby('BAIRRO').agg({
        'TECNICO': 'count',
        'STATUS': lambda x: sum(x.str.upper() == 'EXECUTADO')  # Convertendo para mai√∫sculo para compara√ß√£o
    }).reset_index()
    
    # Calcular taxa de execu√ß√£o com verifica√ß√£o de divis√£o por zero
    bairros_demanda['Taxa de Execu√ß√£o'] = bairros_demanda.apply(
        lambda row: round((row['STATUS'] / row['TECNICO'] * 100), 1) if row['TECNICO'] > 0 else 0.0,
        axis=1
    )
    bairros_demanda = bairros_demanda.sort_values('TECNICO', ascending=False)

    # Mostrar top bairros
    st.markdown("**Top 5 Bairros com Maior Demanda:**")
    for _, row in bairros_demanda.head().iterrows():
        st.write(f"- **{row['BAIRRO']}**: {row['TECNICO']} servi√ßos ({row['Taxa de Execu√ß√£o']}% executados)")

    # Recomenda√ß√µes estrat√©gicas
    st.subheader("üéØ Recomenda√ß√µes Estrat√©gicas")
    
    # Calcular recomenda√ß√µes de aloca√ß√£o
    st.markdown("**Aloca√ß√£o Recomendada de T√©cnicos:**")
    for _, row in bairros_demanda.head().iterrows():
        tecnicos_recomendados = max(2, int(row['TECNICO'] / 50))  # Base: 1 t√©cnico para cada 50 servi√ßos
        st.write(f"- {row['BAIRRO']}: {tecnicos_recomendados} t√©cnicos")

    # Insights adicionais
    st.subheader("üí° Insights Adicionais")
    
    # Calcular efici√™ncia por bairro
    media_execucao = bairros_demanda['Taxa de Execu√ß√£o'].mean()
    bairros_baixa_eficiencia = bairros_demanda[bairros_demanda['Taxa de Execu√ß√£o'] < media_execucao]
    
    # Mostrar insights
    st.markdown("**Principais Observa√ß√µes:**")
    st.write(f"1. Os hor√°rios de pico s√£o: {', '.join(f'{h:02d}:00h' for h in [8, 12, 16])}")
    st.write(f"2. Os dias mais movimentados s√£o: {', '.join(dias_pico.index[:2])}")
    st.write(f"3. Bairros que precisam de aten√ß√£o (abaixo da m√©dia de {media_execucao:.1f}% de execu√ß√£o):")
    for _, row in bairros_baixa_eficiencia.head(3).iterrows():
        st.write(f"   - {row['BAIRRO']}: {row['Taxa de Execu√ß√£o']}% de taxa de execu√ß√£o")

    # M√©tricas de Performance
    st.subheader("üìà M√©tricas de Performance")
    
    try:
        # Tratamento dos dados
        df_map['STATUS'] = df_map['STATUS'].fillna('')
        df_map['STATUS'] = df_map['STATUS'].astype(str).str.upper()
        
        # C√°lculos b√°sicos
        total_servicos = len(df_map)
        total_executados = len(df_map[df_map['STATUS'] == 'EXECUTADO'])
        total_tecnicos = df_map['TECNICO'].fillna('SEM T√âCNICO').nunique()
        total_bairros = df_map['BAIRRO'].fillna('SEM BAIRRO').nunique()
        
        if total_servicos > 0 and total_tecnicos > 0:
            col1, col2, col3 = st.columns(3)
            
            with col1:
                taxa_geral = (total_executados / total_servicos * 100)
                st.metric(
                    "Taxa de Execu√ß√£o Geral",
                    f"{taxa_geral:.1f}%",
                    help="Percentual de servi√ßos executados em rela√ß√£o ao total"
                )
            
            with col2:
                media_servicos = (total_servicos / total_tecnicos)
                st.metric(
                    "M√©dia de Servi√ßos/T√©cnico",
                    f"{media_servicos:.1f}",
                    help="M√©dia de servi√ßos por t√©cnico"
                )
            
            with col3:
                st.metric(
                    "Total de Bairros Atendidos",
                    f"{total_bairros}",
                    help="N√∫mero total de bairros com servi√ßos"
                )
        else:
            st.warning("N√£o h√° dados suficientes para calcular algumas m√©tricas.")
    
    except Exception as e:
        st.warning(f"Erro ao calcular m√©tricas: {str(e)}")
    
else:
    st.warning("N√£o h√° dados com coordenadas v√°lidas para os filtros selecionados.")
